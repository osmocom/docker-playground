#!/bin/bash

usage () {
	USAGE_STR=""
	USAGE_STR="${USAGE_STR}usage: $(basename $0) [-l|--list-files] [-h|--help] [-r|--restore] [-a|--append] [-o|--osmo-ttcn3-branch <OSMO_TTCN3_BRANCH>] [[-n|--no-prompt] [-a|--append] -t|--testcases <TTCN3_TESTCASE>...]\n"
	USAGE_STR="${USAGE_STR}Adapt Osmocom docker-playground to custom needs (branch pointed to, testcomponent and testcases to run).\n"
	USAGE_STR="${USAGE_STR}\n"
	USAGE_STR="${USAGE_STR}	-r, --restore		Restore target files from docker-playground to point to current commit of repository.\n"
	USAGE_STR="${USAGE_STR}	-o, --osmo-ttcn3-branch	Point to branch OSMO_TTCN3_BRANCH of osmo-ttcn3-hacks repo.\n"
	USAGE_STR="${USAGE_STR}	-l, --list-files	List target files that will be changed/restored.\n"
	USAGE_STR="${USAGE_STR}	-n, --no-prompt		Don't prompt for changes.\n"
	USAGE_STR="${USAGE_STR}	-a, --append		Append testcase to existing list of testcases.\n"
	USAGE_STR="${USAGE_STR}	-t, --testcases		Give testcase(s) TTCN3_TESTCASE of format <TTCN3_TESTSTUITE.TC_NAME>. For each '-t' option item, the testsuite prefix (including the dot) need to be given only once. Will prompt for files to manipulate since there are subdirectories sometimes with alternative config files.\n"
	USAGE_STR="${USAGE_STR}				Will not prompt for anything, if docker-playground repository subdirectory SUBDIR with the TTCN3 testconfig is given\n"
	USAGE_STR="${USAGE_STR}				Example:\n"
	USAGE_STR="${USAGE_STR}				-t NS_Tests.TC_sns_sgsn_add TC_sns_sgsn_second_add\n"
	echo -ne "$USAGE_STR"
}

# Actions besides printing usage
OSMO_TTCN3_BRANCH=""
OSMO_TTCN3_BRANCH_OPT=""
OSMO_TTCN3_BRANCH_ESCAPED=""
RESTORE=""
LIST_FILES=""
NO_PROMPT=""
TESTCASE_OPT=""
TESTSUITE=""
TESTCASES=""
TEST_SUBDIR=""
APPEND=""
TESTSUITES=""

user_wants() {
	if [ -n "$NO_PROMPT" ]; then
		return 0
	fi
	PROMPT="$1"
	while true; do
	    read -p "$PROMPT" yn
	    case $yn in
	        [Yy] | [Yy]es)
			return 0
		;;
	        [Nn] | [Nn]o)
			return 1
		;;
	        * ) echo "Please answer yes or no."
		;;
	    esac
	done
}

# Use to test if anything is to be done
while [ "$1" != "" ]; do
	PARAM=$1
	VALUE=$2
	case $PARAM in
		-h | --help)
			usage
			exit
			;;
		-r | --restore)
			RESTORE="yes"
			;;
		-l | --list-files)
			LIST_FILES="yes"
			;;
		-n | --no-prompt)
			NO_PROMPT="yes"
			;;
		-a|--append)
			APPEND="yes"
			;;
		-o | --osmo-ttcn3-branch)
			OSMO_TTCN3_BRANCH_OPT="$PARAM"
			if [ -n "$VALUE" ]; then
				if echo $VALUE | grep -q "^-.*"; then
					shift
					continue; # Restoring is also possible without any given branch, this might indicate the next option
				fi
				OSMO_TTCN3_BRANCH=$VALUE
				OSMO_TTCN3_BRANCH_ESCAPED="$(echo $OSMO_TTCN3_BRANCH | sed 's/\//\\\//g')" # Escape slashes for sed
				shift
			fi
			;;
		-t | --testcases)
			TESTCASE_OPT="$PARAM"
			if echo $VALUE | grep -q "^-.*"; then
				shift
				continue; # Restoring is also possible without any given branch, this might indicate the next option
			fi
			# Loop through testcases until none given or until next option comes
			TESTSUITE_PREV="$(echo $VALUE | grep '\.' | sed 's/\([^\.]\+\)\..*/\1/')" # Get everything before the dot if there is one
			TESTSUITES="$TESTSUITE_PREV"
			while [ -n "$2" ] && ! printf "%s\n" "$2" | grep -q -- '^-.*'; do
				TESTSUITE="$(echo $2 | grep '\.' | sed 's/\([^\.]\+\)\..*/\1/')"
				if [ -z "$TESTSUITE" ] && [ -z "$TESTSUITE_PREV" ]; then # This should only happen in the first loop, if no testsuite prefix was given
					echo "Error: Testsuite prefix missing (including dot '.') for testcase string $2" >&2
					echo "Need such a prefix at least once for each series of testcases for one testsuite" >&2
					exit 1
				elif [ -n "$TESTSUITE" ]; then
					TESTCASES="$TESTCASES $2"
					if [ $TESTSUITE_PREV != $TESTSUITE ]; then
						TESTSUITES="$TESTSUITES $TESTSUITE"
					fi
					TESTSUITE_PREV="$TESTSUITE"
				elif [ -z "$TESTSUITE" ]; then
					TESTCASES="$TESTCASES $TESTSUITE_PREV.$2"
				fi
				shift
			done
			;;
		--)
			break
			;;
		-* | --*)
			echo "Error: Unknown option: $PARAM" >&2
			usage >&2
			exit 1
			;;
		*)
			;;
	esac
	shift
done
TOPIC_SUFFIx="%topix=$TOPIC" REPO_SUFFIX="docker-playground.git"

if [ -n "$TESTCASE_OPT" ] && [ -z "$TESTCASES" ] && [ -z "$RESTORE" ]; then
	echo "Error: No Testcomponent given for option $PARAM" >&2
	exit 1
fi

ACTIONS="$OSMO_TTCN3_BRANCH_ESCAPED\
$RESTORE\
$LIST_FILES\
$TESTCASES"
if [ -z "$ACTIONS" ]; then
	echo "Nothing to do"
	exit 0
fi

if ! URL="$(git config --get remote.origin.url 2>&1)"; then
	echo "Error: Couldn't get origin URL" >&2
	echo "Error message from 'git':" >&2
	echo "$URL" >&2
	exit 1
elif ! echo "$URL" | grep -q ".*$REPO_SUFFIX$"; then
	echo "Error: This is not the 'docker-playground' repository" >&2
	echo "Repository URL is $URL, should end on $REPO_SUFFIX" >&2
	exit 1
elif ! REPO_ROOT="$(git rev-parse --show-toplevel 2>&1)"; then
	echo "Error: Couldn't get repository root directory" >&2
	echo "Reason: $REPO_ROOT" >&2
	exit 1
fi

RESTORE_ERR=0
if [ -n "$OSMO_TTCN3_BRANCH_OPT" ]; then
	DOCKERFILE="./Dockerfile"
	if ! [ -f "$DOCKERFILE" ]; then
		echo "No file $DOCKERFILE found"
		echo "You might want to try to run this in a docker-playground subdirectory with a Dockerfile"
		DOCKERFILE=""
	fi

	# Files in which to put branch name
	FILE_LIST="$REPO_ROOT/make/Makefile $(pwd)/$DOCKERFILE"

	if [ -n "$LIST_FILES" ]; then
		echo "Target files:"
		for file in $FILE_LIST; do
			echo "$file"
		done
		exit 0
	fi

	# Branch replacement
	if [ -n "$RESTORE" ]; then
		for file in $FILE_LIST; do
			if ! git checkout -q $file; then
				echo "Error restoring file $FILE" >&2
				RESTORE_ERR=1
			fi
		done
	elif [ -n "$OSMO_TTCN3_BRANCH_ESCAPED" ]; then
		REPLACE_ERR=0
		TMP_FILE="/tmp/$$_file"
		for file in $FILE_LIST; do
			if ! sed -i 's/\(OSMO_TTCN3_BRANCH[?]\?=\)[^\\]*\(\\\?\)$/\1'"\"$OSMO_TTCN3_BRANCH_ESCAPED\""'\2/g' $file; then
				REPLACE_ERR=1
			fi
			# if ! sed 's/\(OSMO_TTCN3_BRANCH[?]\?=\)[^\\]*\(\\\?\)$/\1'"\"$OSMO_TTCN3_BRANCH_ESCAPED\""'\2/g' $file >$TMP_FILE 2>&1; then
			# 	REPLACE_ERR=1
			# elif ! grep -q $OSMO_TTCN3_BRANCH $TMP_FILE; then
			# 	REPLACE_ERR=1
			# 	echo "Error replacing branchnames in file $file" >&2
			# elif ! cp $TMP_FILE $file; then
			# 	REPLACE_ERR=1
			# fi
			if [ "$REPLACE_ERR" = "1" ]; then
				echo "Couldn't point docker-playground to branch $OSMO_TTCN3_BRANCH_ESCAPED" >&2
			fi
		done
		rm -f $TMP_FILE
	fi
fi

# TODO: Adapt testcases, restore them
if [ -n "$TESTCASE_OPT" ]; then
	# TESTSUITE LOOP. Maybe not the most elegant solution
	for testsuite in $TESTSUITES; do
		TESTSUITE_CFG="$testsuite.cfg"
		FILE_LIST="$(find $REPO_ROOT -name "$TESTSUITE_CFG" -exec readlink -f {} \;)"
		FILES="$(echo "$FILE_LIST" | wc -l)"
		for file in $FILE_LIST; do
			if [ -n "$RESTORE" ]; then
				if ! git checkout -q "$file"; then
					echo "Error restoring file $FILE" >&2
					RESTORE_ERR=1
				fi
				continue
			fi
			if [ -z "$TEST_SUBDIR" ]; then
				FNAME_STR="/$TESTSUITE_CFG"
			else
				FNAME_STR="/$TEST_SUBDIR/$TESTSUITE_CFG"
			fi
			if [ -n "$TESTCASES" ] && echo "$file" | grep -q "[^/]*$FNAME_STR"; then
				if ! ( ([ -z "$TEST_SUBDIR" ] && user_wants "Adapt file $file?") ||  # Multiple cfg files possible, so we prompt
					[ -n "$TEST_SUBDIR" ] ); then # UNVERIFIED ASSUMPTION: Only expecting one cfg file in each subdir
					break; # Avoid too many nested ifs...
				fi
				TMP_FILE="/tmp/$$_file"
				TESTCASE_REGEX="$testsuite"'\.[^\t ]*'
				EXECUTE_LINE="^[ \t]*\[EXECUTE\][ \t\\]*$"
				NEXT_SECTION_LINE="\[[A-Z_a-z0-9]\+\]"
				# Delete all lines of the EXECUTE cfg section
				if [ -z "$APPEND" ]; then
					if ! sed -i '/'"$EXECUTE_LINE"'/,/^'"$NEXT_SECTION_LINE"'/{/^'"$EXECUTE_LINE"'/!{/^'"$NEXT_SECTION_LINE"'/!d}}' $file; then
						echo "Error removing existing testcases from file $file" >&2
						REPLACE_ERR=1
					fi
				fi
				# Append testcase lines
				for tc in $TESTCASES; do
					tc_testsuite="$(echo $tc | grep '\.' | sed 's/\([^\.]\+\)\..*/\1/')"
					if [ $testsuite != $tc_testsuite ]; then
						continue
					fi
					if ! sed -i '/'"$EXECUTE_LINE"'/a '"$tc" $file; then
						echo "Error appending testcase lines" >&2
						REPLACE_ERR=1
					fi
				done
			fi
		done
	done
	exit $REPLACE_ERR
fi
